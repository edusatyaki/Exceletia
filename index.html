<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultra-Dense Waist-High Grass & Interactive Map</title>
  
  <link href="https://fonts.googleapis.com/css?family=Oswald:200,300,500" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
    }
    
    /* --- HORIZONTAL GLASSMORPHISM UI --- */
    #ui { 
      position: absolute; bottom: 30px; width: 100%; display: flex;
      justify-content: center; pointer-events: none; z-index: 10;
      opacity: 0; transition: opacity 1s ease;
    }
    .glass-bar {
      display: flex; flex-direction: row; align-items: center; gap: 20px;
      background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50px; padding: 12px 30px; box-shadow: 0 10px 40px 0 rgba(0, 0, 0, 0.5); color: #fff;
    }
    .glass-bar h1 { 
      margin: 0; font-size: 15px; font-weight: 600; letter-spacing: 3px; 
      text-transform: uppercase; padding-right: 20px; border-right: 1px solid rgba(255, 255, 255, 0.2); 
    }
    .control-group { display: flex; gap: 20px; font-size: 13px; color: #cbd5e1; letter-spacing: 1px; }
    .glass-bar b { color: #4cd137; background: rgba(255, 255, 255, 0.1); padding: 3px 8px; border-radius: 6px; margin-right: 6px; font-weight: bold; } 
    .btn-container { display: flex; gap: 10px; pointer-events: auto; padding-left: 10px; border-left: 1px solid rgba(255, 255, 255, 0.2); }
    .action-btn {
      padding: 8px 20px; font-size: 12px; font-weight: bold; letter-spacing: 1.5px;
      color: #fff; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 20px;
      cursor: pointer; transition: 0.3s; text-transform: uppercase;
    }
    .action-btn:hover { background: #4cd137; color: #000; border-color: #4cd137; box-shadow: 0 0 15px rgba(76, 209, 55, 0.5); }
    #btn-map { display: none; background: rgba(52, 152, 219, 0.3); border-color: #3498db; }
    #btn-map:hover { background: #3498db; color: #fff; box-shadow: 0 0 15px rgba(52, 152, 219, 0.6); }

    /* --- TOAST NOTIFICATION --- */
    #toast {
      position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
      background: rgba(46, 204, 113, 0.2); border: 1px solid #2ecc71;
      backdrop-filter: blur(10px); color: #fff; padding: 15px 30px;
      border-radius: 30px; font-size: 14px; font-weight: bold; letter-spacing: 2px;
      text-transform: uppercase; box-shadow: 0 0 20px rgba(46, 204, 113, 0.4);
      opacity: 0; visibility: hidden; transition: opacity 0.5s ease; z-index: 15;
    }

    /* --- MAP MODAL & VUE APP STYLES --- */
    :root { --text: #FFF; --light: #34495D; --medium: #EE7738; --dark: #fcae44; }
    #map-modal {
      position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
      display: flex; align-items: center; justify-content: center;
      z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.4s ease;
    }
    .map-content {
      background: #1e293b; border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 30px; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      display: flex; flex-direction: column; align-items: center; width: 80vw; max-width: 1000px;
      font-family: 'Oswald', sans-serif; color: var(--text);
    }
    #map-app { width: 100%; display: flex; flex-direction: column; align-items: center; }
    
    .custom-map { display: block; width: 100%; height: auto; max-height: 60vh; margin: 0 auto 1rem; overflow: visible; }
    
    .region-shape { stroke: rgba(255,255,255,0.1); stroke-width: 2; transition: all 0.3s; }
    .region-shape:hover { stroke: rgba(255,255,255,0.5); filter: brightness(1.2); }
    
    .region-label { font-size: 32px; font-weight: 500; fill: #fff; pointer-events: none; text-anchor: middle; letter-spacing: 2px;}
    .region-node { fill: #fff; stroke: var(--dark); stroke-width: 4; }
    
    .marker-connector { fill: none; stroke: var(--dark); stroke-width: 4; stroke-dasharray: 8 8; pointer-events: none; animation: marching-ants 1s linear 0s infinite; }
    @keyframes marching-ants { from { stroke-dashoffset: 0; } to { stroke-dashoffset: 16; } }
    .airplane { pointer-events: none; fill: #FFF; filter: drop-shadow(0px 5px 10px rgba(0,0,0,0.5)); }

    #close-map {
      margin-top: 10px; padding: 10px 40px; font-size: 14px; font-weight: bold; letter-spacing: 2px;
      color: #fff; background: #e74c3c; border: none; border-radius: 30px; cursor: pointer; transition: 0.2s;
    }
    #close-map:hover { background: #c0392b; transform: scale(1.05); }

    /* --- LOADING SCREENS --- */
    #loading, #start-screen {
      position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; transition: opacity 0.8s ease, visibility 0.8s ease;
    }
    #loading { background: #05080c; }
    #start-screen { background: rgba(0,0,0,0.6); backdrop-filter: blur(12px); visibility: hidden; opacity: 0; }
    #loading-text { font-size: 14px; color: #fff; text-transform: uppercase; letter-spacing: 5px; margin-bottom: 25px; opacity: 0.8; }
    .progress-container { width: 350px; height: 2px; background: rgba(255, 255, 255, 0.1); overflow: hidden; }
    #progress-bar { width: 0%; height: 100%; background: #4cd137; transition: width 0.2s ease; }
    #start-screen h2 { margin-bottom: 30px; color: #fff; font-weight: 300; letter-spacing: 8px; text-transform: uppercase; }
    #start-screen button {
      padding: 15px 50px; font-size: 14px; letter-spacing: 3px; color: #fff; background: rgba(255, 255, 255, 0.1); 
      border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 30px; cursor: pointer; font-weight: bold; transition: 0.3s;
    }
    #start-screen button:hover { background: #fff; color: #000; transform: scale(1.05); }
  </style>
</head>
<body>

  <div id="loading">
    <div id="loading-text">Seeding 1.5 Million Grass Blades...</div>
    <div class="progress-container"><div id="progress-bar"></div></div>
  </div>
  <div id="start-screen">
    <h2>Dense Grassland Expedition</h2>
    <button id="start-btn">Begin Journey</button>
  </div>

  <div id="toast">üó∫Ô∏è You have mapped the area! [Press M]</div>

  <div id="map-modal">
    <div class="map-content">
      <div id="map-app">
        <svg class="custom-map" ref="map" width="1200" height="780" viewBox="0 0 1200 780">
            <path class="region-shape" fill="#3b82f6" d="M50,150 Q150,50 350,100 T400,300 T200,450 T50,350 Z" /> 
            <path class="region-shape" fill="#8b5cf6" d="M450,50 Q650,20 800,150 T850,350 T600,300 T450,150 Z" /> 
            <path class="region-shape" fill="#10b981" d="M750,400 Q950,300 1100,450 T1150,650 T900,750 T750,550 Z" /> 
            <path class="region-shape" fill="#f59e0b" d="M150,550 Q300,450 500,550 T650,700 T400,750 T150,650 Z" /> 
            
            <path id="flight-path" class="marker-connector" :d="flightPath"></path>

            <g class="airplane">
                <animateMotion dur="8s" repeatCount="indefinite" rotate="auto">
                    <mpath href="#flight-path" />
                </animateMotion>
                <path d="M21 15.984l-8.016-2.484v5.484l2.016 1.5v1.5l-3.516-0.984-3.469 0.984v-1.5l1.969-1.5v-5.484l-7.969 2.484v-1.969l7.969-5.016v-5.484c0-0.844 0.656-1.5 1.5-1.5s1.5 0.656 1.5 1.5v5.484l8.016 5.016v1.969z" transform="translate(-16,-15) scale(1.6)"></path>
            </g>

            <g v-for="(region, index) in regions" :key="region.name">
                <circle class="region-node" :cx="region.x" :cy="region.y" r="10"></circle>
                <circle :fill="region.color" :cx="region.x" :cy="region.y" r="5"></circle>
                <text class="region-label" :x="region.x" :y="region.y - 25">{{ index + 1 }}. {{ region.name }}</text>
            </g>
        </svg>
      </div>
      <button id="close-map">CLOSE MAP</button>
    </div>
  </div>

  <div id="ui">
    <div class="glass-bar">
      <h1>Wilderness</h1>
      <div class="control-group">
        <span><b>WASD</b> Move</span>
        <span><b>Mouse</b> Look</span>
        <span><b>F</b> Torch</span>
      </div>
      <div class="btn-container">
        <button class="action-btn" id="btn-time">Day Mode</button>
        <button class="action-btn" id="btn-map">View Map (M)</button>
      </div>
    </div>
  </div>

  <script type="module">
    // --- UPDATED IMPORTS (Using esm.sh which automatically resolves all Three.js dependencies natively) ---
    import * as THREE from 'https://esm.sh/three@0.136.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://esm.sh/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const GRASS_INSTANCES = 1500000; 
    const WORLD_SIZE = 160; 
    const GRASS_HEIGHT = 0.75; 

    // --- GAME STATE ---
    let distanceWalked = 0;
    let mapUnlocked = false;
    let mapOpen = false;

    const ambientAudio = new Audio('https://actions.google.com/sounds/v1/weather/winter_wind_loop.ogg');
    ambientAudio.loop = true; ambientAudio.volume = 0.4;

    const loadingScreen = document.getElementById('loading');
    const startScreen = document.getElementById('start-screen');
    const uiScreen = document.getElementById('ui');
    const startBtn = document.getElementById('start-btn');
    const btnTime = document.getElementById('btn-time');
    const btnMap = document.getElementById('btn-map');
    const toast = document.getElementById('toast');
    const mapModal = document.getElementById('map-modal');
    const closeMapBtn = document.getElementById('close-map');

    const manager = new THREE.LoadingManager();
    manager.onProgress = (u, loaded, total) => { document.getElementById('progress-bar').style.width = (loaded / total * 100) + '%'; };
    manager.onLoad = () => {
      document.getElementById('loading-text').innerText = "Initializing Engine...";
      setTimeout(() => {
        buildWorld();
        loadingScreen.style.opacity = '0';
        setTimeout(() => { loadingScreen.style.visibility = 'hidden'; startScreen.style.visibility = 'visible'; startScreen.style.opacity = '1'; }, 800);
      }, 100);
    };

    startBtn.addEventListener('click', () => {
      ambientAudio.play().catch(e => console.log("Audio play prevented"));
      startScreen.style.opacity = '0'; uiScreen.style.opacity = '1';
      torchOn = true; if (torchLight && torchGlow) { torchLight.intensity = 150.0; torchGlow.intensity = 20.0; }
      setTimeout(() => { startScreen.style.visibility = 'hidden'; animate(); }, 500);
    });

    // 1. CORE SETUP
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8); 

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.outputEncoding = THREE.sRGBEncoding; renderer.toneMapping = THREE.ACESFilmicToneMapping; 
    renderer.toneMappingExposure = 1.0; renderer.physicallyCorrectLights = true; 
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; 
    controls.minDistance = 2; controls.maxDistance = 15;
    controls.enablePan = false;

    // 2. DAY/NIGHT SYSTEM
    const nightConfig = { fogColor: new THREE.Color(0x060912), hemiSky: new THREE.Color(0x162032), hemiGround: new THREE.Color(0x050810), hemiInt: 0.4, dirColor: new THREE.Color(0x7799bb), dirInt: 0.8, dirPos: new THREE.Vector3(30, 50, -30) };
    const dayConfig = { fogColor: new THREE.Color(0x87ceeb), hemiSky: new THREE.Color(0xffffff), hemiGround: new THREE.Color(0x445544), hemiInt: 1.0, dirColor: new THREE.Color(0xfffaee), dirInt: 4.0, dirPos: new THREE.Vector3(50, 100, 50) };

    let isNight = true; let targetConfig = nightConfig;
    scene.fog = new THREE.FogExp2(nightConfig.fogColor, 0.02); scene.background = nightConfig.fogColor;

    const hemiLight = new THREE.HemisphereLight(nightConfig.hemiSky, nightConfig.hemiGround, nightConfig.hemiInt); scene.add(hemiLight);
    const mainLight = new THREE.DirectionalLight(nightConfig.dirColor, nightConfig.dirInt); 
    mainLight.position.copy(nightConfig.dirPos); mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048; mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.camera.near = 10; mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = mainLight.shadow.camera.bottom = - WORLD_SIZE/2;
    mainLight.shadow.camera.right = mainLight.shadow.camera.top = WORLD_SIZE/2;
    mainLight.shadow.bias = -0.0005; scene.add(mainLight);

    btnTime.addEventListener('click', () => {
        isNight = !isNight; targetConfig = isNight ? nightConfig : dayConfig;
        btnTime.innerText = isNight ? "Day Mode" : "Night Mode";
        if (!isNight && torchOn) { torchOn = false; torchLight.intensity = 0; torchGlow.intensity = 0; }
    });

    // 3. CHARACTER & TORCH
    let character, mixer, idleAction, walkAction;
    let isWalking = false, torchOn = false;
    
    const torchLight = new THREE.SpotLight(0xffeedd, 0, 80, Math.PI / 5, 0.6, 1.5); 
    torchLight.castShadow = true; torchLight.shadow.mapSize.width = 1024; torchLight.shadow.mapSize.height = 1024; torchLight.shadow.bias = -0.0005;
    const torchGlow = new THREE.PointLight(0xffeedd, 0, 5); const torchTarget = new THREE.Object3D();

    const gltfLoader = new GLTFLoader(manager);
    
    // --- UPDATED MODEL URL (Using jsdelivr for guaranteed MIME type and reliability) ---
    gltfLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r136/examples/models/gltf/Soldier.glb', (gltf) => {
      character = gltf.scene;
      character.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
      
      torchLight.position.set(0, 2.5, 0.2); torchTarget.position.set(0, 0.5, 10); 
      torchLight.target = torchTarget; torchGlow.position.set(0, 2.5, 0.2); 
      
      character.add(torchLight); character.add(torchTarget); character.add(torchGlow); 
      scene.add(character);
      controls.target.set(0, 1.2, 0); mainLight.target = character;

      mixer = new THREE.AnimationMixer(character);
      idleAction = mixer.clipAction(gltf.animations[0]); walkAction = mixer.clipAction(gltf.animations[3]); 
      walkAction.setEffectiveWeight(1); idleAction.setEffectiveWeight(1); idleAction.play();
    });

    function hash(n) { return (Math.sin(n) * 43758.5453123) % 1; }
    function noise(x, z) {
        const pX = Math.floor(x), pZ = Math.floor(z);
        const fX = x - pX, fZ = z - pZ;
        const fX2 = fX * fX * (3.0 - 2.0 * fX), fZ2 = fZ * fZ * (3.0 - 2.0 * fZ);
        const n00 = hash(pX + pZ * 57.0), n10 = hash(pX + 1.0 + pZ * 57.0);
        const n01 = hash(pX + (pZ + 1.0) * 57.0), n11 = hash(pX + 1.0 + (pZ + 1.0) * 57.0);
        return (n00 + fX2 * (n10 - n00)) + fZ2 * ((n01 + fX2 * (n11 - n01)) - (n00 + fX2 * (n10 - n00)));
    }
    
    function getTerrainData(x, z) {
        let e = noise(x * 0.03, z * 0.03) * 2.5; 
        e += noise(x * 0.15, z * 0.15) * 0.5; 
        let s = noise(x * 0.05, z * 0.05); 
        s = Math.max(0, Math.min(1, s + (e * 0.1))); 
        let centerFlat = Math.min(Math.sqrt(x*x + z*z) / 8, 1.0);
        return { height: e * centerFlat, snowFactor: s * centerFlat }; 
    }

    function toggleMap() {
        mapOpen = !mapOpen;
        if(mapOpen) { mapModal.style.visibility = 'visible'; mapModal.style.opacity = '1'; } 
        else { mapModal.style.opacity = '0'; setTimeout(() => mapModal.style.visibility = 'hidden', 400); }
    }
    btnMap.addEventListener('click', toggleMap);
    closeMapBtn.addEventListener('click', toggleMap);

    let groundGeo, positions, instancedGrass;
    const planeSegments = 250; 

    function buildWorld() {
        groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, planeSegments, planeSegments);
        groundGeo.rotateX(-Math.PI / 2); 
        positions = groundGeo.attributes.position.array;
        const colors = [];
        const cGreen = new THREE.Color(0x11210b); const cSnow = new THREE.Color(0xaabbcc); 

        for (let i = 0; i < positions.length; i += 3) {
            const vx = positions[i], vz = positions[i + 2];
            const data = getTerrainData(vx, vz);
            positions[i + 1] = data.height; 
            let c = cGreen.clone().lerp(cSnow, data.snowFactor);
            colors.push(c.r, c.g, c.b);
        }
        groundGeo.computeVertexNormals();
        groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const groundMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.9, flatShading: true });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.receiveShadow = true; scene.add(groundMesh);

        const bladeGeo = new THREE.PlaneGeometry(0.08, GRASS_HEIGHT, 1, 3); 
        bladeGeo.translate(0, GRASS_HEIGHT / 2, 0); 

        const grassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5, side: THREE.DoubleSide });
        
        grassMat.onBeforeCompile = (shader) => {
            shader.uniforms.time = { value: 0 }; shader.uniforms.playerPos = { value: new THREE.Vector3(0, -1000, 0) }; 
            shader.vertexShader = `
                uniform float time; uniform vec3 playerPos;
                attribute vec3 instanceColor; attribute float instanceSnow; attribute float instanceCurve;
                varying vec3 vColor; varying float vSnow; varying float vY; 
                ${shader.vertexShader}
            `.replace('#include <begin_vertex>', `
                #include <begin_vertex>
                vec4 worldInstancePosition = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                vColor = instanceColor; vSnow = instanceSnow; vY = position.y; 
                
                float h = position.y / ${GRASS_HEIGHT.toFixed(2)};
                transformed.x *= (1.0 - h * 0.9); 
                transformed.z += pow(h, 2.0) * instanceCurve;

                float distToPlayer = distance(worldInstancePosition.xz, playerPos.xz);
                float trampleRadius = 0.8; 
                float trample = 1.0 - smoothstep(0.0, trampleRadius, distToPlayer); 
                if(trample > 0.0) {
                    vec2 pushDir = normalize(worldInstancePosition.xz - playerPos.xz);
                    transformed.x += pushDir.x * trample * h * 0.6; 
                    transformed.z += pushDir.y * trample * h * 0.6; 
                    transformed.y -= trample * h * 0.4; 
                }

                float windStrength = h * 0.15; 
                float wind = sin(time * 3.0 + worldInstancePosition.x * 0.5 + worldInstancePosition.z * 0.5) * windStrength; 
                transformed.x += wind; transformed.z += wind * 0.5;
            `);
            shader.fragmentShader = `
                varying vec3 vColor; varying float vSnow; varying float vY;
                ${shader.fragmentShader}
            `.replace('#include <color_fragment>', `
                #include <color_fragment>
                float h = clamp(vY / ${GRASS_HEIGHT.toFixed(2)}, 0.0, 1.0);
                
                vec3 bottomColor = vec3(0.01, 0.04, 0.0); 
                vec3 topColor = vColor; 

                vec3 bladeColor = mix(bottomColor, topColor, h); 
                float snowMix = step(0.65, vSnow); 
                diffuseColor.rgb = mix(bladeColor, vec3(0.85, 0.85, 0.9), snowMix); 
            `);
            grassMat.userData.shader = shader;
        };

        instancedGrass = new THREE.InstancedMesh(bladeGeo, grassMat, GRASS_INSTANCES);
        instancedGrass.castShadow = true;
        
        const dummy = new THREE.Object3D();
        const instColors = new Float32Array(GRASS_INSTANCES * 3);
        const snowData = new Float32Array(GRASS_INSTANCES);
        const curveData = new Float32Array(GRASS_INSTANCES); 
        
        const cLushTips = new THREE.Color(0x66ff33); 
        const cForestTips = new THREE.Color(0x44bb11); 
        const cDryTips = new THREE.Color(0xaabb44); 
        
        for (let i = 0; i < GRASS_INSTANCES; i++) {
            const x = (Math.random() - 0.5) * WORLD_SIZE; 
            const z = (Math.random() - 0.5) * WORLD_SIZE;
            const data = getTerrainData(x, z);
            
            dummy.position.set(x, data.height, z); 
            dummy.rotation.y = Math.random() * Math.PI * 2; 
            dummy.rotation.x = (Math.random() - 0.5) * 0.15; 
            dummy.scale.set(1.0, 0.7 + Math.random() * 0.4, 1.0); 
            dummy.updateMatrix(); instancedGrass.setMatrixAt(i, dummy.matrix);

            let bladeColor;
            let rand = Math.random();
            if (rand < 0.10) { bladeColor = cDryTips; } 
            else { bladeColor = cForestTips.clone().lerp(cLushTips, Math.random()); }

            instColors[i*3] = bladeColor.r; instColors[i*3+1] = bladeColor.g; instColors[i*3+2] = bladeColor.b;
            snowData[i] = data.snowFactor;
            
            curveData[i] = 0.05 + Math.random() * 0.15; 
        }
        instancedGrass.geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instColors, 3));
        instancedGrass.geometry.setAttribute('instanceSnow', new THREE.InstancedBufferAttribute(snowData, 1));
        instancedGrass.geometry.setAttribute('instanceCurve', new THREE.InstancedBufferAttribute(curveData, 1));
        scene.add(instancedGrass);
    }

    const keys = { forward: false, backward: false, left: false, right: false };
    window.addEventListener('keydown', (e) => {
        if(e.code === 'KeyW' || e.code === 'ArrowUp') keys.forward = true; 
        if(e.code === 'KeyS' || e.code === 'ArrowDown') keys.backward = true;
        if(e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = true; 
        if(e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = true;
        if(e.code === 'KeyF') { torchOn = !torchOn; torchLight.intensity = torchOn ? 150.0 : 0.0; torchGlow.intensity = torchOn ? 20.0 : 0.0; }
        if(e.code === 'KeyM' && mapUnlocked) toggleMap();
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'KeyW' || e.code === 'ArrowUp') keys.forward = false; 
        if(e.code === 'KeyS' || e.code === 'ArrowDown') keys.backward = false;
        if(e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = false; 
        if(e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = false;
    });

    const clock = new THREE.Clock();
    const speed = 1.6; 

    function animate() {
      requestAnimationFrame(animate);
      
      if(mapOpen) return; 

      const delta = Math.min(clock.getDelta(), 0.1);
      if (mixer) mixer.update(delta);
      const time = clock.getElapsedTime();

      scene.fog.color.lerp(targetConfig.fogColor, 0.02); scene.background = scene.fog.color;
      hemiLight.color.lerp(targetConfig.hemiSky, 0.02); hemiLight.groundColor.lerp(targetConfig.hemiGround, 0.02);
      hemiLight.intensity = THREE.MathUtils.lerp(hemiLight.intensity, targetConfig.hemiInt, 0.02);
      mainLight.color.lerp(targetConfig.dirColor, 0.02); mainLight.intensity = THREE.MathUtils.lerp(mainLight.intensity, targetConfig.dirInt, 0.02);
      mainLight.position.lerp(targetConfig.dirPos, 0.02);

      if (instancedGrass && instancedGrass.material.userData.shader) {
          instancedGrass.material.userData.shader.uniforms.time.value = time;
          if (character) instancedGrass.material.userData.shader.uniforms.playerPos.value.copy(character.position);
      }

      if (character && positions) {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
        const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

        let moveDir = new THREE.Vector3();
        if (keys.forward) moveDir.add(camDir); if (keys.backward) moveDir.sub(camDir);
        if (keys.left) moveDir.sub(camRight); if (keys.right) moveDir.add(camRight);

        const walkingNow = moveDir.lengthSq() > 0;
        
        if (walkingNow && !isWalking) { walkAction.reset().play().crossFadeFrom(idleAction, 0.3, true); isWalking = true; } 
        else if (!walkingNow && isWalking) { idleAction.reset().play().crossFadeFrom(walkAction, 0.3, true); isWalking = false; }

        if (walkingNow) {
          moveDir.normalize();
          character.position.addScaledVector(moveDir, speed * delta);
          
          distanceWalked += speed * delta;
          if (distanceWalked > 15 && !mapUnlocked) {
              mapUnlocked = true;
              btnMap.style.display = 'block';
              toast.style.visibility = 'visible'; toast.style.opacity = '1';
              setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.style.visibility = 'hidden', 500); }, 4000);
          }
          
          const limit = WORLD_SIZE / 2 - 2;
          if (character.position.x > limit) character.position.x = limit; if (character.position.x < -limit) character.position.x = -limit;
          if (character.position.z > limit) character.position.z = limit; if (character.position.z < -limit) character.position.z = -limit;

          character.position.y = getTerrainData(character.position.x, character.position.z).height;

          const targetAngle = Math.atan2(moveDir.x, moveDir.z) + Math.PI;
          let diff = targetAngle - character.rotation.y;
          while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
          character.rotation.y += diff * 10 * delta;

          const segSize = WORLD_SIZE / planeSegments; const halfSize = WORLD_SIZE / 2;
          const px = character.position.x; const pz = character.position.z;
          const gridX = Math.round((px + halfSize) / segSize); const gridZ = Math.round((pz + halfSize) / segSize);
          const deformRadius = 0.4; const maxDepth = -0.15; const searchR = Math.ceil(deformRadius / segSize) + 1;
          let needsUpdate = false;

          for (let z = gridZ - searchR; z <= gridZ + searchR; z++) {
              for (let x = gridX - searchR; x <= gridX + searchR; x++) {
                  if (x < 0 || x > planeSegments || z < 0 || z > planeSegments) continue;
                  const vIdx = z * (planeSegments + 1) + x, i = vIdx * 3;
                  const vx = positions[i]; const vy = positions[i+1], vz = positions[i+2]; 
                  const dist = Math.sqrt((vx - px)*(vx - px) + (vz - pz)*(vz - pz));
                  if (dist < deformRadius) {
                      const data = getTerrainData(vx, vz);
                      const targetY = data.height + (maxDepth * Math.cos((dist / deformRadius) * (Math.PI / 2))) * data.snowFactor;
                      if (vy > targetY) { positions[i+1] = targetY; needsUpdate = true; }
                  }
              }
          }
          if (needsUpdate) { groundGeo.attributes.position.needsUpdate = true; groundGeo.computeVertexNormals(); }
        }

        const targetLookAt = new THREE.Vector3(character.position.x, character.position.y + 1.2, character.position.z);
        controls.target.lerp(targetLookAt, 0.1); controls.update();
      }
      renderer.render(scene, camera);
    }

    // Vue JS initialization for the Custom Map
    new Vue({
        el: '#map-app',
        data: () => ({
            regions: [
                { name: 'Exeletia', x: 230, y: 240, color: '#3b82f6' },
                { name: 'Numex',    x: 630, y: 170, color: '#8b5cf6' },
                { name: 'Plotesia', x: 940, y: 550, color: '#10b981' },
                { name: 'Pandesia', x: 420, y: 600, color: '#f59e0b' }
            ],
            flightPath: ''
        }),
        mounted() {
            this.generateFlightPath();
        },
        methods: {
            generateFlightPath() {
                // Creates a smooth curve connecting 1 -> 2 -> 3 -> 4
                const p1 = this.regions[0];
                const p2 = this.regions[1];
                const p3 = this.regions[2];
                const p4 = this.regions[3];
                
                // M: Move to P1. Q: Curve to P2. T: Smooth curve to P3. T: Smooth curve to P4.
                this.flightPath = `M ${p1.x} ${p1.y} Q 400 50 ${p2.x} ${p2.y} T ${p3.x} ${p3.y} T ${p4.x} ${p4.y}`;
            }
        }
    });

    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
