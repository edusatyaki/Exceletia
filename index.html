<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dark Night: Realistic Grassland Walk</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
    }
    
    /* --- OVERLAYS --- */
    #ui { 
      position: absolute; 
      bottom: 40px; 
      width: 100%; 
      text-align: center; 
      pointer-events: none; 
      z-index: 10;
      opacity: 0;
      transition: opacity 1s ease;
    }
    .controls-box {
      background: rgba(8, 10, 14, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: inline-block; 
      padding: 15px 35px;
      border-radius: 50px; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.9);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: #e0e0e0;
    }
    h1 { 
      margin: 0 0 8px 0; color: #fff; font-size: 18px; 
      font-weight: 300; letter-spacing: 5px; text-transform: uppercase;
    }
    p { margin: 0; font-size: 13px; color: #b3c2d1; letter-spacing: 1px; }
    b { color: #4cd137; } 
    
    #loading {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      background: #05080c; z-index: 20; 
      transition: opacity 0.8s ease, visibility 0.8s ease;
    }
    #loading-text {
      font-size: 16px; color: #fff; text-transform: uppercase;
      letter-spacing: 4px; margin-bottom: 20px;
    }
    .progress-container {
      width: 300px; height: 3px; background: rgba(255, 255, 255, 0.1);
      border-radius: 2px; overflow: hidden; position: relative;
    }
    #progress-bar {
      width: 0%; height: 100%; background: #4cd137;
      transition: width 0.2s ease;
      box-shadow: 0 0 10px rgba(76, 209, 55, 0.8);
    }
    
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.8); backdrop-filter: blur(8px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 15; visibility: hidden; opacity: 0; transition: opacity 0.5s ease;
    }
    #start-screen button {
      padding: 15px 40px; font-size: 18px; font-family: inherit; letter-spacing: 2px;
      color: #111; background: #fff; border: none; border-radius: 30px;
      cursor: pointer; box-shadow: 0 5px 25px rgba(255, 255, 255, 0.3);
      font-weight: bold;
      transition: transform 0.2s, background 0.2s;
    }
    #start-screen button:hover { background: #ddd; transform: scale(1.05); }
  </style>
</head>
<body>

  <div id="loading">
    <div id="loading-text">Generating Dark Night...</div>
    <div class="progress-container">
      <div id="progress-bar"></div>
    </div>
  </div>
  
  <div id="start-screen">
    <h1 style="margin-bottom: 20px; color: #fff; letter-spacing: 4px;">Midnight Expedition</h1>
    <button id="start-btn">TURN ON LIGHTS</button>
  </div>

  <div id="ui">
    <div class="controls-box">
      <h1>Dark Plains</h1>
      <p><b>W A S D</b> to Walk &nbsp;|&nbsp; <b>F</b> to Toggle Torch &nbsp;|&nbsp; <b>Mouse</b> to Look</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const GRASS_INSTANCES = 150000; 
    const GRASS_RANGE = 50; 

    // --- AUDIO SETUP ---
    const ambientAudio = new Audio('https://actions.google.com/sounds/v1/weather/winter_wind_loop.ogg');
    ambientAudio.loop = true;
    ambientAudio.volume = 0.5;

    const loadingScreen = document.getElementById('loading');
    const startScreen = document.getElementById('start-screen');
    const uiScreen = document.getElementById('ui');
    const startBtn = document.getElementById('start-btn');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');

    const manager = new THREE.LoadingManager();
    manager.onProgress = function (url, itemsLoaded, itemsTotal) {
      progressBar.style.width = (itemsLoaded / itemsTotal * 100) + '%';
    };
    manager.onLoad = function () {
      loadingText.innerText = "Initializing Engine...";
      setTimeout(() => {
        buildWorld();
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
          loadingScreen.style.visibility = 'hidden';
          startScreen.style.visibility = 'visible';
          startScreen.style.opacity = '1';
        }, 800);
      }, 100);
    };

    startBtn.addEventListener('click', () => {
      ambientAudio.play().catch(e => console.log("Audio play prevented:", e));
      startScreen.style.opacity = '0';
      uiScreen.style.opacity = '1';
      // Automatically turn the torch on when entering the game
      torchOn = true;
      if (torchLight && torchGlow) {
          torchLight.intensity = 150.0;
          torchGlow.intensity = 25.0;
      }
      setTimeout(() => {
        startScreen.style.visibility = 'hidden';
        animate(); 
      }, 500);
    });

    // 1. CORE SETUP WITH DARK NIGHT GRAPHICS
    const scene = new THREE.Scene();
    
    // Deep, dark night fog
    const fogColor = new THREE.Color(0x060912); 
    scene.fog = new THREE.FogExp2(fogColor, 0.04); 
    scene.background = fogColor;

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8); 

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping; 
    renderer.toneMappingExposure = 0.8; // Darker exposure
    renderer.physicallyCorrectLights = true; 
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; 
    controls.minDistance = 2; controls.maxDistance = 15;
    controls.enablePan = false;

    // 2. REALISTIC DIM MOONLIGHT
    // Much darker ambient lighting to make the torch necessary
    const hemiLight = new THREE.HemisphereLight(0x162032, 0x050810, 0.4); 
    scene.add(hemiLight);
    
    // Dim moonlight
    const moonLight = new THREE.DirectionalLight(0x7799bb, 0.8); 
    moonLight.position.set(30, 50, -30); 
    moonLight.castShadow = true;
    moonLight.shadow.mapSize.width = 2048; 
    moonLight.shadow.mapSize.height = 2048;
    moonLight.shadow.camera.near = 10; 
    moonLight.shadow.camera.far = 150;
    moonLight.shadow.camera.left = moonLight.shadow.camera.bottom = - GRASS_RANGE;
    moonLight.shadow.camera.right = moonLight.shadow.camera.top = GRASS_RANGE;
    moonLight.shadow.bias = -0.0005;
    scene.add(moonLight);

    // 3. LOAD THE HUMAN CHARACTER & OVERHEAD TORCH
    let character, mixer, idleAction, walkAction;
    let isWalking = false;
    let torchOn = false;
    
    // Main Flashlight Beam (SpotLight)
    const torchLight = new THREE.SpotLight(0xffeedd, 0, 80, Math.PI / 5, 0.6, 1.5); 
    torchLight.castShadow = true;
    torchLight.shadow.mapSize.width = 1024;
    torchLight.shadow.mapSize.height = 1024;
    torchLight.shadow.bias = -0.0005;
    
    // Secondary "Glow" Light (Illuminates the character's head/shoulders)
    const torchGlow = new THREE.PointLight(0xffeedd, 0, 5);

    const torchTarget = new THREE.Object3D();

    const gltfLoader = new GLTFLoader(manager);
    gltfLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/Soldier.glb', (gltf) => {
      character = gltf.scene;
      character.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
      
      // ATTACH LIGHTS OVERHEAD
      // Position the torch above the character's head (Height ~2.2)
      torchLight.position.set(0, 2.2, 0.2); 
      // Point the target slightly downward towards the ground ahead
      torchTarget.position.set(0, 0.5, 10); 
      torchLight.target = torchTarget;
      
      // Position the glow exactly where the light source is to illuminate the top of the character
      torchGlow.position.set(0, 2.2, 0.2); 
      
      character.add(torchLight);
      character.add(torchTarget); 
      character.add(torchGlow); 

      scene.add(character);
      character.position.set(0, 0, 0); 
      controls.target.set(0, 1.2, 0);

      mixer = new THREE.AnimationMixer(character);
      idleAction = mixer.clipAction(gltf.animations[0]); 
      walkAction = mixer.clipAction(gltf.animations[3]); // Calm walking animation
      walkAction.setEffectiveWeight(1); idleAction.setEffectiveWeight(1);
      idleAction.play();
    });

    // 4. TERRAIN MATH (Fractal Noise)
    function hash(n) { return (Math.sin(n) * 43758.5453123) % 1; }
    function noise(x, z) {
        const pX = Math.floor(x), pZ = Math.floor(z);
        const fX = x - pX, fZ = z - pZ;
        const fX2 = fX * fX * (3.0 - 2.0 * fX), fZ2 = fZ * fZ * (3.0 - 2.0 * fZ);
        const n00 = hash(pX + pZ * 57.0), n10 = hash(pX + 1.0 + pZ * 57.0);
        const n01 = hash(pX + (pZ + 1.0) * 57.0), n11 = hash(pX + 1.0 + (pZ + 1.0) * 57.0);
        return (n00 + fX2 * (n10 - n00)) + fZ2 * ((n01 + fX2 * (n11 - n01)) - (n00 + fX2 * (n10 - n00)));
    }
    
    function getTerrainData(x, z) {
        let e = noise(x * 0.03, z * 0.03) * 2.0; 
        e += noise(x * 0.2, z * 0.2) * 0.2; 
        let s = noise(x * 0.1, z * 0.1); 
        s = Math.max(0, Math.min(1, s + (e * 0.1))); 
        let centerFlat = Math.min(Math.sqrt(x*x + z*z) / 5, 1.0);
        return { height: e * centerFlat, snowFactor: s * centerFlat }; 
    }

    function generateBumpMap() {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(512, 512);
        for (let i = 0; i < imgData.data.length; i += 4) {
            const val = Math.random() * 255; 
            imgData.data[i] = val; imgData.data[i+1] = val; imgData.data[i+2] = val; imgData.data[i+3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(50, 50);
        return texture;
    }

    // 5. BUILD WORLD & GRASS
    let groundGeo, positions, instancedGrass;
    const planeSegments = 250; 

    function buildWorld() {
        groundGeo = new THREE.PlaneGeometry(GRASS_RANGE * 2, GRASS_RANGE * 2, planeSegments, planeSegments);
        groundGeo.rotateX(-Math.PI / 2); 
        positions = groundGeo.attributes.position.array;
        const colors = [];
        const cGreen = new THREE.Color(0x0e1709); // Extremely dark soil for night
        const cSnow = new THREE.Color(0x8a9ba8); // Dimly lit snow

        for (let i = 0; i < positions.length; i += 3) {
            const vx = positions[i], vz = positions[i + 2];
            const data = getTerrainData(vx, vz);
            positions[i + 1] = data.height;
            let c = cGreen.clone().lerp(cSnow, data.snowFactor);
            colors.push(c.r, c.g, c.b);
        }
        groundGeo.computeVertexNormals();
        groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const bumpTexture = generateBumpMap();
        const groundMat = new THREE.MeshStandardMaterial({ 
          vertexColors: true, 
          roughness: 0.9, 
          bumpMap: bumpTexture, 
          bumpScale: 0.04, // Slightly deeper bumps for torch shadows
          flatShading: true
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // --- KNEE-LEVEL GRASS ---
        const bladeGeo = new THREE.ConeGeometry(0.02, 0.15, 3);
        bladeGeo.translate(0, 0.075, 0); 

        const grassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, side: THREE.DoubleSide });

        grassMat.onBeforeCompile = (shader) => {
            shader.uniforms.time = { value: 0 };
            shader.vertexShader = `
                uniform float time;
                attribute vec3 instanceColor;
                attribute float instanceSnow;
                varying vec3 vColor;
                varying float vSnow;
                varying float vY; 
                ${shader.vertexShader}
            `.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                vec4 worldInstancePosition = instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);
                vColor = instanceColor;
                vSnow = instanceSnow; 
                vY = position.y; 

                float windStrength = position.y * 0.6; 
                float wind = sin(time * 2.0 + worldInstancePosition.x * 0.5 + worldInstancePosition.z * 0.5) * windStrength;
                transformed.x += wind;
                transformed.z += wind * 0.5;
                `
            );
            shader.fragmentShader = `
                varying vec3 vColor;
                varying float vSnow;
                varying float vY;
                ${shader.fragmentShader}
            `.replace(
                '#include <color_fragment>',
                `
                #include <color_fragment>
                vec3 bottomColor = vColor * 0.3;
                vec3 topColor = vColor * 1.2;
                vec3 bladeColor = mix(bottomColor, topColor, clamp(vY / 0.15, 0.0, 1.0)); 
                float snowMix = step(0.65, vSnow); 
                diffuseColor.rgb = mix(bladeColor, vec3(0.6, 0.6, 0.7), snowMix); // Nighttime snow grass
                `
            );
            grassMat.userData.shader = shader;
        };

        instancedGrass = new THREE.InstancedMesh(bladeGeo, grassMat, GRASS_INSTANCES);
        instancedGrass.castShadow = true;
        
        placeGrassInstances();
        scene.add(instancedGrass);
    }

    function placeGrassInstances() {
        const dummy = new THREE.Object3D();
        const colors = new Float32Array(GRASS_INSTANCES * 3);
        const snowData = new Float32Array(GRASS_INSTANCES);
        
        const cDarkGreen = new THREE.Color(0x0e2b0b); 
        const cLightGreen = new THREE.Color(0x1a450d); // Darker grass base colors for night
        
        for (let i = 0; i < GRASS_INSTANCES; i++) {
            const x = (Math.random() - 0.5) * GRASS_RANGE;
            const z = (Math.random() - 0.5) * GRASS_RANGE;
            const data = getTerrainData(x, z);

            dummy.position.set(x, data.height - 0.01, z); 
            dummy.rotation.y = Math.random() * Math.PI; 
            dummy.rotation.x = (Math.random() - 0.5) * 0.2; 
            dummy.scale.set(1.0, 0.5 + Math.random() * 0.5, 1.0); 
            dummy.updateMatrix();
            instancedGrass.setMatrixAt(i, dummy.matrix);

            let bladeColor = cDarkGreen.clone().lerp(cLightGreen, Math.random());
            colors[i*3] = bladeColor.r; colors[i*3+1] = bladeColor.g; colors[i*3+2] = bladeColor.b;
            snowData[i] = data.snowFactor;
        }
        instancedGrass.geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(colors, 3));
        instancedGrass.geometry.setAttribute('instanceSnow', new THREE.InstancedBufferAttribute(snowData, 1));
    }

    // 6. INPUT HANDLING
    const keys = { forward: false, backward: false, left: false, right: false };
    
    window.addEventListener('keydown', (e) => {
        if(e.code === 'KeyW' || e.code === 'ArrowUp') keys.forward = true; 
        if(e.code === 'KeyS' || e.code === 'ArrowDown') keys.backward = true;
        if(e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = true; 
        if(e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = true;
        
        // TOGGLE TORCH LOGIC
        if(e.code === 'KeyF') {
            torchOn = !torchOn;
            torchLight.intensity = torchOn ? 150.0 : 0.0; // High intensity for Physically Correct Lights
            torchGlow.intensity = torchOn ? 25.0 : 0.0; 
        }
    });

    window.addEventListener('keyup', (e) => {
        if(e.code === 'KeyW' || e.code === 'ArrowUp') keys.forward = false; 
        if(e.code === 'KeyS' || e.code === 'ArrowDown') keys.backward = false;
        if(e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = false; 
        if(e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = false;
    });

    // 7. MAIN GAME LOOP
    const clock = new THREE.Clock();
    const speed = 1.6; 

    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.1);
      if (mixer) mixer.update(delta);
      const time = clock.getElapsedTime();

      if (instancedGrass && instancedGrass.material.userData.shader) {
          instancedGrass.material.userData.shader.uniforms.time.value = time;
      }

      if (character && positions) {
        const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
        const camRight = new THREE.Vector3(); camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

        let moveDir = new THREE.Vector3();
        if (keys.forward) moveDir.add(camDir); if (keys.backward) moveDir.sub(camDir);
        if (keys.left) moveDir.sub(camRight); if (keys.right) moveDir.add(camRight);

        const walkingNow = moveDir.lengthSq() > 0;
        
        if (walkingNow && !isWalking) { 
            walkAction.reset().play().crossFadeFrom(idleAction, 0.3, true); 
            isWalking = true;
        } else if (!walkingNow && isWalking) { 
            idleAction.reset().play().crossFadeFrom(walkAction, 0.3, true); 
            isWalking = false; 
        }

        if (walkingNow) {
          moveDir.normalize();
          character.position.addScaledVector(moveDir, speed * delta);
          character.position.y = getTerrainData(character.position.x, character.position.z).height;

          const targetAngle = Math.atan2(moveDir.x, moveDir.z) + Math.PI;
          let diff = targetAngle - character.rotation.y;
          while (diff < -Math.PI) diff += Math.PI * 2; while (diff > Math.PI) diff -= Math.PI * 2;
          character.rotation.y += diff * 10 * delta;
        }

        const targetLookAt = new THREE.Vector3(character.position.x, character.position.y + 1.2, character.position.z);
        controls.target.lerp(targetLookAt, 0.1); controls.update();

        const px = character.position.x;
        const pz = character.position.z;
        instancedGrass.position.set(
            Math.floor(px / GRASS_RANGE + 0.5) * GRASS_RANGE,
            0,
            Math.floor(pz / GRASS_RANGE + 0.5) * GRASS_RANGE
        );

        if (walkingNow) {
          const segSize = (GRASS_RANGE * 2) / planeSegments;
          const halfSize = (GRASS_RANGE * 2) / 2;
          
          const lpx = character.position.x - instancedGrass.position.x; 
          const lpz = character.position.z - instancedGrass.position.z;

          const gridX = Math.round((lpx + halfSize) / segSize);
          const gridZ = Math.round((lpz + halfSize) / segSize);
          
          const deformRadius = 0.4; 
          const maxDepth = -0.15; 
          const searchR = Math.ceil(deformRadius / segSize) + 1;
          let needsUpdate = false;

          for (let z = gridZ - searchR; z <= gridZ + searchR; z++) {
              for (let x = gridX - searchR; x <= gridX + searchR; x++) {
                  if (x < 0 || x > planeSegments || z < 0 || z > planeSegments) continue;
                  const vIdx = z * (planeSegments + 1) + x, i = vIdx * 3;
                  const vx = positions[i] + instancedGrass.position.x; 
                  const vy = positions[i+1], vz = positions[i+2] + instancedGrass.position.z; 
                  const dx = vx - character.position.x, dz = vz - character.position.z;
                  const dist = Math.sqrt(dx*dx + dz*dz);
                  
                  if (dist < deformRadius) {
                      const data = getTerrainData(vx, vz);
                      const targetY = data.height + (maxDepth * Math.cos((dist / deformRadius) * (Math.PI / 2))) * data.snowFactor;
                      if (vy > targetY) { positions[i+1] = targetY; needsUpdate = true; }
                  }
              }
          }
          if (needsUpdate) { groundGeo.attributes.position.needsUpdate = true; groundGeo.computeVertexNormals(); }
        }
      }
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
